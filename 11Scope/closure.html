<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body style="background-color: #1f1f1f; color: white">
    <!-- Practical user-case  -->
    <button id="orange">orange</button>
    <button id="green">green</button>

    <script>
      function clickHandle(color) {
        // document.body.style.backgroundColor = `${color}`

        return function () {
          document.body.style.backgroundColor = `${color}`;
        };
      }

      document.querySelector("#orange").onclick = clickHandle("orange");

      document.querySelector("#green").onclick = clickHandle("green");
    </script>
  </body>
  <!-- Explantion of closure  -->
  <!-- <script>
    function makeFunc() {
      const name = "Mozilla"
      function displayName() {
        console.log(name)
      }
      return displayName // 1. Now here instead of returning the function we are returning only the reference 
    }

    const myFunc = makeFunc() 
    myFunc()

    // 2. So when we call the makeFunc() (in line 37) it return the displayName function here and one would think that the  makeFunc() would be gone and then we cannot get the value of name from it now to displayName()

    // 3. But that would be wrong and the concepts of "Closure" comes into play which says although we have removed the scope of the function but now memory reference comes into play so when we do,  
    
     const myFunc = makeFunc() 

     not only displayName is returned if there is a outer function that exists the scope of the outer function would also be returned.

    
  </script> -->
</html>
